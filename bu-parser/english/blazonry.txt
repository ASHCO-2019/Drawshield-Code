#
# The definition of the language of blazonry in a variant Backas_Naur Form (BNF)
#
# Differences from BNF are:
#
# * non_terminals do not have to be surrounded by angle brackets (but can be)
# * There are various flags available, which can appear before or after the symbol
#   The symbol / can be used to separate the symbol from its flags if preferred
# 
# Flags that modify production rules
# * symbols flagged with ? are optional
# * symbols flagged with * can appear more than once
# 
# Flags that affect the parsing process but can generally be ignored
# * symbols flagged with ^ are discarded from the parse tree once found
# * The flag = causes its attributes to be copied up to the parent node
#		and the symbol is then discarded

#############
# Discard error words
#############

error^		::= t_unknown ! Word not recognised

#############
# Punctuation  
#############

andd		::= t_andd= t_comma | \
				t_comma t_andd= | \
				t_andd= | \
				t_comma
semi2		::= t_semicolon t_semicolon
semi1		::=	t_semicolon

#############
# Tinctures  
#############
# TODO can't remember how grady is supposed to work
treatment 	::= t_treatment2 colour ?andd^ colour | \
				colour t_treatment2 colour | \
				t_treatment1 colour
fur 		::= t_fur=
colour		::= t_colour=
proper		::= t_proper=
backref		::= t_backref  # expand this?
counter		::= t_counterchange
semy		::= t_semy ?t_wordof charge

tincture 	::= treatment | fur | colour | proper | backref | counter | semy


#############
# Modifiers
#############

modifier 	::= t_divmods= ?andd^ | t_orientation= ?andd^ | t_ordmods= | \
				t_colour_mod= ?andd^ | t_voided= ?andd^ | t_ordprefix= ?andd^ | \
				t_linetype= ?andd^ |


#############
# Divisions
#############
div_type3	::=	t_division3 tincture ?andd^ tincture ?andd^ tincture | \
				t_division3x tincture ?andd^ tincture ?andd^ tincture
counterdiv	::= div_type2 t_division2 counter  # test / expand this
div_type2	::= t_division2 tincture ?andd^ tincture  | \
				t_division3x tincture ?andd^ tincture


division 	::= div_type2 ?modifier* | \
			 	div_type3 ?modifier* | \
			 	counterdiv


#############
# Ordinaries
#############

ord_type1	::= t_number1 ?ordprefix t_ordinary1= | \
				t_number1 ?ordprefix t_ordinaryconf= | \
				t_number1 ?ordprefix t_ordorcharge= 
ord_type2	::= t_number1 ?ordprefix t_ordinary2= | \
				t_number2 ?ordprefix t_ordinary2= 
ord_type3	::= t_number1 ?ordprefix t_ordinary3= | \
				t_number2 ?ordprefix t_ordinary3= | \
				t_number3 ?ordprefix t_ordinary3= 

ord_type	::= ord_type1= | ord_type2= | ord_type3=
ordinary	::=	ord_type= tincture ?modifier* ?semi1^ | \
				ord_type= ?modifier* tincture ?semi1^

on_ordinary	::= t_wordon= ordinary charge | \
				t_wordon= ordinary ordinary

bare_ordinary ::= ord_type= ?modifier* ?semi1^

#############
# Simple Charges (for now)
#############

charge		::= t_number2 t_charge2x= tincture | \
				anynumber t_charge2x= tincture | \
				anynumber t_charge= tincture

anynumber	::= t_number1= | t_number2= | t_number3= | t_numberx=

#############
# Objects (on the field)
#############
object		::= charge ?andd^ | ordinary ?andd^ | on_ordinary  ?andd^ | bare_ordinary ?andd^

objects@		::= object*

#############
# Field
#############
field		::= tincture | division

#############
# Overall (a simple shield)
#############
overall		::= t_overall objects


#############
# Simple shield
#############

simple@ ::= field objects ?overall | \
				 field


#############
# Quarterings
#############

quartermarker	::= ?t_wordthe^ t_quarters ?t_quartermark^ | \
					?t_wordthe^ anynumber t_quartermark^ | \
					?t_wordthe^ t_letters t_quartermark^

#############
# shield
#############

shield ::= simple

#############
# blazon
#############

blazon ::= shield

##########################
# Look for some common errors
##########################
# If we didn't find a legitimate reduction above, look for some common errors
# This is not wasteful as they are only processed if there is no match above

bad_division ::= t_division2 tincture | \
				 t_division2 | \
				 t_division3 tincture ?andd^ tincture | \
				 t_division3 ! Wrong number of tinctures for division

bad_treatment ::= t_treatment2 colour | \
				  colour t_treatment 2 | \
				  t_treatment2 |\
				  t_treatment1 ! Wrong number of colours for treatment





    
    

